ðŸ”„ Project Awareness & Context
- Always review project planning and architecture documents (e.g., PLANNING.md) at the start of a new task or conversation.
- Check the task list (e.g., TASK.md) before starting work. If your task isn't listed, add it with a brief description and today's date.
- Follow established naming conventions, file structures, and architectural patterns as described in project documentation.

ðŸ§± Code Structure & Modularity
- Avoid files longer than 500 lines. If a file grows too large, refactor by splitting it into smaller modules or helper files.
- Organize code into clearly separated modules or files, grouped by feature or responsibility.
- Use clear and consistent import/include/require statements as appropriate for the language and project.

ðŸ§ª Testing & Reliability
- Always create unit tests for new features (functions, classes, routes, etc.), using the preferred testing framework for the language.
- After updating any logic, review and update existing tests as needed.
- Place tests in a dedicated tests directory that mirrors the main code structure.
- For each feature, include at least:
  - One test for expected/typical use
  - One edge case test
  - One failure or error case test

âœ… Task Completion
- Mark completed tasks in the task list (e.g., TASK.md) immediately after finishing them.
- Add any new sub-tasks or TODOs discovered during development to the task list under a "Discovered During Work" section.

ðŸ“Ž Style & Conventions
- Follow the official or community style guide for the language in use (e.g., PEP8, Google Java Style, Airbnb JavaScript Style).
- Use consistent naming conventions for variables, functions, classes, and files (e.g., camelCase, snake_case, PascalCase) as appropriate.
- Write clear, descriptive names for all identifiers; avoid unnecessary abbreviations.
- Indent code consistently (spaces or tabs as per project/language standard).
- Limit line length to 80â€“120 characters, depending on language norms.
- Use comments to explain non-obvious logic, intent, and complex algorithms.
- Write documentation comments for all public functions, classes, and modules.
- Group related code by feature or responsibility.
- Remove dead code and unused variables/functions promptly.
- Prefer immutability and pure functions where practical.
- Avoid deep nesting; refactor complex logic into smaller functions.
- Use version control best practices: small, focused commits with clear messages.
- Ensure code is understandable and maintainable by others.

ðŸ“š Documentation & Explainability
- Update project documentation (e.g., README.md) when new features are added, dependencies change, or setup steps are modified.
- Comment non-obvious code and ensure everything is understandable to a mid-level developer.
- When writing complex logic, add inline comments explaining the "why," not just the "what."

ðŸ§  AI/Automation Behavior Rules
- Never assume missing context; ask questions if uncertain.
- Never invent or hallucinate libraries, functions, or APIsâ€”only use known, verified components.
- Always confirm file paths and module names exist before referencing them in code or documentation.
- Never delete or overwrite existing code unless explicitly instructed or if it is part of a documented task.
